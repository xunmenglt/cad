{"version":3,"sources":["../../../src/iterators/make-iterator/make-iterator.ts"],"names":["makeStringIterator","makeArrayBufferIterator","makeBlobIterator","makeStreamIterator","isBlob","isReadableStream","isResponse","makeIterator","data","options","ArrayBuffer","response","body","Error"],"mappings":"AAEA,SAAQA,kBAAR,QAAiC,wBAAjC;AACA,SAAQC,uBAAR,QAAsC,8BAAtC;AACA,SAAQC,gBAAR,QAA+B,sBAA/B;AAEA,SAAQC,kBAAR,QAAiC,wBAAjC;AACA,SAAQC,MAAR,EAAgBC,gBAAhB,EAAkCC,UAAlC,QAAmD,gCAAnD;AAiBA,OAAO,SAASC,YAAT,CACLC,IADK,EAELC,OAFK,EAG+C;AACpD,MAAI,OAAOD,IAAP,KAAgB,QAApB,EAA8B;AAE5B,WAAOR,kBAAkB,CAACQ,IAAD,EAAOC,OAAP,CAAzB;AACD;;AACD,MAAID,IAAI,YAAYE,WAApB,EAAiC;AAC/B,WAAOT,uBAAuB,CAACO,IAAD,EAAOC,OAAP,CAA9B;AACD;;AACD,MAAIL,MAAM,CAACI,IAAD,CAAV,EAAkB;AAChB,WAAON,gBAAgB,CAACM,IAAD,EAAeC,OAAf,CAAvB;AACD;;AACD,MAAIJ,gBAAgB,CAACG,IAAD,CAApB,EAA4B;AAC1B,WAAOL,kBAAkB,CAACK,IAAD,EAAyBC,OAAzB,CAAzB;AACD;;AACD,MAAIH,UAAU,CAACE,IAAD,CAAd,EAAsB;AACpB,UAAMG,QAAQ,GAAGH,IAAjB;AACA,WAAOL,kBAAkB,CAACQ,QAAQ,CAACC,IAAV,EAAkCH,OAAlC,CAAzB;AACD;;AACD,QAAM,IAAII,KAAJ,CAAU,cAAV,CAAN;AACD","sourcesContent":["import type {ReadStream} from 'fs';\r\n\r\nimport {makeStringIterator} from './make-string-iterator';\r\nimport {makeArrayBufferIterator} from './make-array-buffer-iterator';\r\nimport {makeBlobIterator} from './make-blob-iterator';\r\nimport type {StreamIteratorOptions} from './make-stream-iterator';\r\nimport {makeStreamIterator} from './make-stream-iterator';\r\nimport {isBlob, isReadableStream, isResponse} from '../../javascript-utils/is-type';\r\n\r\n/**\r\n * @param [options.chunkSize]\r\n */\r\nexport type IteratorOptions = StreamIteratorOptions & {\r\n  chunkSize?: number;\r\n};\r\n\r\n/**\r\n * Returns an iterator that breaks its input into chunks and yields them one-by-one.\r\n * @param data\r\n * @param options\r\n * @returns\r\n * This function can e.g. be used to enable data sources that can only be read atomically\r\n * (such as `Blob` and `File` via `FileReader`) to still be parsed in batches.\r\n */\r\nexport function makeIterator(\r\n  data: ArrayBuffer | string | Blob | Response | ReadableStream | ReadStream,\r\n  options?: IteratorOptions\r\n): AsyncIterable<ArrayBuffer> | Iterable<ArrayBuffer> {\r\n  if (typeof data === 'string') {\r\n    // Note: Converts string chunks to binary\r\n    return makeStringIterator(data, options);\r\n  }\r\n  if (data instanceof ArrayBuffer) {\r\n    return makeArrayBufferIterator(data, options);\r\n  }\r\n  if (isBlob(data)) {\r\n    return makeBlobIterator(data as Blob, options);\r\n  }\r\n  if (isReadableStream(data)) {\r\n    return makeStreamIterator(data as ReadableStream, options);\r\n  }\r\n  if (isResponse(data)) {\r\n    const response = data as Response;\r\n    return makeStreamIterator(response.body as ReadableStream, options);\r\n  }\r\n  throw new Error('makeIterator');\r\n}\r\n"],"file":"make-iterator.js"}