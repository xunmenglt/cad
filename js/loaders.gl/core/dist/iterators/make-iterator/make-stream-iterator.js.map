{"version":3,"sources":["../../../src/iterators/make-iterator/make-stream-iterator.ts"],"names":["isBrowser","toArrayBuffer","makeStreamIterator","stream","options","makeBrowserStreamIterator","makeNodeStreamIterator","reader","getReader","nextBatchPromise","currentBatchPromise","read","_streamReadAhead","done","value","error","releaseLock","chunk"],"mappings":"AACA,SAAQA,SAAR,EAAmBC,aAAnB,QAAuC,0BAAvC;AAUA,OAAO,SAASC,kBAAT,CACLC,MADK,EAELC,OAFK,EAGuB;AAC5B,SAAOJ,SAAS,GACZK,yBAAyB,CAACF,MAAD,EAA2BC,OAA3B,CADb,GAEZE,sBAAsB,CAACH,MAAD,EAAqBC,OAArB,CAF1B;AAGD;;AAOD,gBAAgBC,yBAAhB,CACEF,MADF,EAEEC,OAFF,EAG8B;AAU5B,QAAMG,MAAM,GAAGJ,MAAM,CAACK,SAAP,EAAf;AAEA,MAAIC,gBAAJ;;AAEA,MAAI;AAEF,WAAO,IAAP,EAAa;AACX,YAAMC,mBAAmB,GAAGD,gBAAgB,IAAIF,MAAM,CAACI,IAAP,EAAhD;;AAGA,UAAIP,OAAJ,aAAIA,OAAJ,eAAIA,OAAO,CAAEQ,gBAAb,EAA+B;AAC7BH,QAAAA,gBAAgB,GAAGF,MAAM,CAACI,IAAP,EAAnB;AACD;;AAGD,YAAM;AAACE,QAAAA,IAAD;AAAOC,QAAAA;AAAP,UAAgB,MAAMJ,mBAA5B;;AAEA,UAAIG,IAAJ,EAAU;AACR;AACD;;AAED,YAAMZ,aAAa,CAACa,KAAD,CAAnB;AACD;AACF,GAnBD,CAmBE,OAAOC,KAAP,EAAc;AAGdR,IAAAA,MAAM,CAACS,WAAP;AACD;AACF;;AAOD,gBAAgBV,sBAAhB,CACEH,MADF,EAEEC,OAFF,EAG8B;AAG5B,aAAW,MAAMa,KAAjB,IAA0Bd,MAA1B,EAAkC;AAChC,UAAMF,aAAa,CAACgB,KAAD,CAAnB;AACD;AACF","sourcesContent":["import type {Readable} from 'stream';\r\nimport {isBrowser, toArrayBuffer} from '@loaders.gl/loader-utils';\r\n\r\nexport type StreamIteratorOptions = {\r\n  _streamReadAhead?: boolean;\r\n};\r\n\r\n/**\r\n * Returns an async iterable that reads from a stream (works in both Node.js and browsers)\r\n * @param stream stream to iterator over\r\n */\r\nexport function makeStreamIterator(\r\n  stream: ReadableStream | Readable,\r\n  options?: StreamIteratorOptions\r\n): AsyncIterable<ArrayBuffer> {\r\n  return isBrowser\r\n    ? makeBrowserStreamIterator(stream as ReadableStream, options)\r\n    : makeNodeStreamIterator(stream as Readable, options);\r\n}\r\n\r\n/**\r\n * Returns an async iterable that reads from a DOM (browser) stream\r\n * @param stream stream to iterate from\r\n * @see https://jakearchibald.com/2017/async-iterators-and-generators/#making-streams-iterate\r\n */\r\nasync function* makeBrowserStreamIterator(\r\n  stream: ReadableStream,\r\n  options?: StreamIteratorOptions\r\n): AsyncIterable<ArrayBuffer> {\r\n  // WhatWG: stream is supposed to have a `getIterator` method\r\n  // if (typeof stream.getIterator === 'function') {\r\n  //   return stream.getIterator();\r\n  // }\r\n  // if (typeof stream[Symbol.asyncIterator] === 'function') {\r\n  //   return makeToArrayBufferIterator(stream);\r\n  // }\r\n\r\n  // In the browser, we first need to get a lock on the stream\r\n  const reader = stream.getReader();\r\n\r\n  let nextBatchPromise: Promise<{done?: boolean; value?: Uint8Array}> | undefined;\r\n\r\n  try {\r\n    // eslint-disable-next-line no-constant-condition\r\n    while (true) {\r\n      const currentBatchPromise = nextBatchPromise || reader.read();\r\n      // Issue a read for an additional batch, while we await the next batch\r\n      // Idea is to make fetching happen in parallel with processing / parsing\r\n      if (options?._streamReadAhead) {\r\n        nextBatchPromise = reader.read();\r\n      }\r\n      // Read from the stream\r\n      // value is a Uint8Array\r\n      const {done, value} = await currentBatchPromise;\r\n      // Exit if we're done\r\n      if (done) {\r\n        return;\r\n      }\r\n      // Else yield the chunk\r\n      yield toArrayBuffer(value);\r\n    }\r\n  } catch (error) {\r\n    // TODO - examples makes it look like this should always be called,\r\n    // but that generates exceptions so only call it if we do not reach the end\r\n    reader.releaseLock();\r\n  }\r\n}\r\n\r\n/**\r\n * Returns an async iterable that reads from a DOM (browser) stream\r\n * @param stream stream to iterate from\r\n * @note Requires Node.js >= 10\r\n */\r\nasync function* makeNodeStreamIterator(\r\n  stream: Readable,\r\n  options?: StreamIteratorOptions\r\n): AsyncIterable<ArrayBuffer> {\r\n  // Hacky test for node version to ensure we don't call bad polyfills\r\n  // NODE 10+: stream is an asyncIterator\r\n  for await (const chunk of stream) {\r\n    yield toArrayBuffer(chunk); // Coerce each chunk to ArrayBuffer\r\n  }\r\n}\r\n/* TODO - remove NODE < 10\r\n * @see https://github.com/bustle/streaming-iterables, MIT license\r\n *\r\n  if (typeof stream[Symbol.asyncIterator] === 'function') {\r\n    return;\r\n  }\r\n\r\n  // TODO - check if is this ever used in Node 10+?\r\n  // eslint-disable-next-line no-constant-condition\r\n  while (true) {\r\n    const data = stream.read();\r\n    if (data !== null) {\r\n      yield toArrayBuffer(data);\r\n      // eslint-disable-next-line no-continue\r\n      continue;\r\n    }\r\n    if (stream._readableState?.ended) {\r\n      return;\r\n    }\r\n    await onceReadable(stream);\r\n  }\r\n\r\nasync function onceReadable(stream: Readable): Promise<any> {\r\n  return new Promise((resolve) => {\r\n    stream.once('readable', resolve);\r\n  });\r\n}\r\n  */\r\n"],"file":"make-stream-iterator.js"}