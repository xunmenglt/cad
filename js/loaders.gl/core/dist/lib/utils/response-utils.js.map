{"version":3,"sources":["../../../src/lib/utils/response-utils.ts"],"names":["isResponse","getResourceContentLength","getResourceUrlAndType","makeResponse","resource","headers","contentLength","String","url","type","initialDataUrl","getInitialDataUrl","TextEncoder","encode","response","Response","Object","defineProperty","value","checkResponse","ok","message","getResponseError","Error","checkResponseSync","status","statusText","length","slice","contentType","get","text","includes","error","INITIAL_DATA_LENGTH","Blob","blobSlice","Promise","resolve","reader","FileReader","onload","event","target","result","readAsDataURL","ArrayBuffer","base64","arrayBufferToBase64","buffer","binary","bytes","Uint8Array","i","byteLength","fromCharCode","btoa"],"mappings":"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","sourcesContent":["import {isResponse} from '../../javascript-utils/is-type';\r\nimport {getResourceContentLength, getResourceUrlAndType} from './resource-utils';\r\n\r\n/**\r\n * Returns a Response object\r\n * Adds content-length header when possible\r\n *\r\n * @param resource\r\n */\r\nexport async function makeResponse(resource: any): Promise<Response> {\r\n  if (isResponse(resource)) {\r\n    return resource;\r\n  }\r\n\r\n  // Add content-length header if possible\r\n  const headers: {[header: string]: string} = {};\r\n\r\n  const contentLength = getResourceContentLength(resource);\r\n  if (contentLength >= 0) {\r\n    headers['content-length'] = String(contentLength);\r\n  }\r\n\r\n  // `new Response(File)` does not preserve content-type and URL\r\n  // so we add them here\r\n  const {url, type} = getResourceUrlAndType(resource);\r\n  if (type) {\r\n    headers['content-type'] = type;\r\n  }\r\n\r\n  // Add a custom header with initial bytes if available\r\n  const initialDataUrl = await getInitialDataUrl(resource);\r\n  if (initialDataUrl) {\r\n    headers['x-first-bytes'] = initialDataUrl;\r\n  }\r\n\r\n  // TODO - is this the best way of handling strings?\r\n  // Maybe package as data URL instead?\r\n  if (typeof resource === 'string') {\r\n    // Convert to ArrayBuffer to avoid Response treating it as a URL\r\n    resource = new TextEncoder().encode(resource);\r\n  }\r\n\r\n  // Attempt to create a Response from the resource, adding headers and setting url\r\n  const response = new Response(resource, {headers});\r\n  // We can't control `Response.url` via constructor, use a property override to record URL.\r\n  Object.defineProperty(response, 'url', {value: url});\r\n  return response;\r\n}\r\n\r\n/**\r\n * Checks response status (async) and throws a helpful error message if status is not OK.\r\n * @param response\r\n */\r\nexport async function checkResponse(response: Response): Promise<void> {\r\n  if (!response.ok) {\r\n    const message = await getResponseError(response);\r\n    throw new Error(message);\r\n  }\r\n}\r\n\r\n/**\r\n * Checks response status (sync) and throws a helpful error message if status is not OK.\r\n * @param response\r\n */\r\nexport function checkResponseSync(response: Response): void {\r\n  if (!response.ok) {\r\n    let message = `${response.status} ${response.statusText}`;\r\n    message = message.length > 60 ? `${message.slice(60)}...` : message;\r\n    throw new Error(message);\r\n  }\r\n}\r\n\r\n// HELPERS\r\n\r\nasync function getResponseError(response): Promise<string> {\r\n  let message = `Failed to fetch resource ${response.url} (${response.status}): `;\r\n  try {\r\n    const contentType = response.headers.get('Content-Type');\r\n    let text = response.statusText;\r\n    if (contentType.includes('application/json')) {\r\n      text += ` ${await response.text()}`;\r\n    }\r\n    message += text;\r\n    message = message.length > 60 ? `${message.slice(60)}...` : message;\r\n  } catch (error) {\r\n    // eslint forbids return in a finally statement, so we just catch here\r\n  }\r\n  return message;\r\n}\r\n\r\nasync function getInitialDataUrl(resource): Promise<string | null> {\r\n  const INITIAL_DATA_LENGTH = 5;\r\n  if (typeof resource === 'string') {\r\n    return `data:,${resource.slice(0, INITIAL_DATA_LENGTH)}`;\r\n  }\r\n  if (resource instanceof Blob) {\r\n    const blobSlice = resource.slice(0, 5);\r\n    return await new Promise((resolve) => {\r\n      const reader = new FileReader();\r\n      reader.onload = (event) => resolve(event?.target?.result as string);\r\n      reader.readAsDataURL(blobSlice);\r\n    });\r\n  }\r\n  if (resource instanceof ArrayBuffer) {\r\n    const slice = resource.slice(0, INITIAL_DATA_LENGTH);\r\n    const base64 = arrayBufferToBase64(slice);\r\n    return `data:base64,${base64}`;\r\n  }\r\n  return null;\r\n}\r\n\r\n// https://stackoverflow.com/questions/9267899/arraybuffer-to-base64-encoded-string\r\nfunction arrayBufferToBase64(buffer) {\r\n  let binary = '';\r\n  const bytes = new Uint8Array(buffer);\r\n  for (let i = 0; i < bytes.byteLength; i++) {\r\n    binary += String.fromCharCode(bytes[i]);\r\n  }\r\n  return btoa(binary);\r\n}\r\n"],"file":"response-utils.js"}