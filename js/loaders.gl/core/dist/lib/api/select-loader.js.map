{"version":3,"sources":["../../../src/lib/api/select-loader.ts"],"names":["compareArrayBuffers","normalizeLoader","getResourceUrlAndType","getRegisteredLoaders","isBlob","EXT_PATTERN","selectLoader","data","loaders","options","context","validHTTPResponse","loader","selectLoaderSync","nothrow","slice","arrayBuffer","Error","getNoValidLoaderMessage","Array","isArray","candidateLoaders","concat","ignoreRegisteredLoaders","push","normalizeLoaders","selectLoaderInternal","url","type","testUrl","mimeType","findLoaderByMIMEType","findLoaderByUrl","findLoaderByInitialBytes","fallbackMimeType","Response","status","message","getFirstCharacters","match","exec","extension","findLoaderByExtension","toLowerCase","loaderExtension","extensions","mimeTypes","includes","id","testDataAgainstText","ArrayBuffer","isView","testDataAgainstBinary","buffer","byteOffset","testText","tests","some","test","startsWith","testBinary","byteLength","magic","getMagicString","length","dataView","DataView","i","String","fromCharCode","getUint8"],"mappings":"AACA,SAAQA,mBAAR,QAAkC,0BAAlC;AACA,SAAQC,eAAR,QAA8B,kCAA9B;AACA,SAAQC,qBAAR,QAAoC,yBAApC;AACA,SAAQC,oBAAR,QAAmC,oBAAnC;AACA,SAAQC,MAAR,QAAqB,gCAArB;AAEA,MAAMC,WAAW,GAAG,YAApB;AAeA,OAAO,eAAeC,YAAf,CACLC,IADK,EAELC,OAA0B,GAAG,EAFxB,EAGLC,OAHK,EAILC,OAJK,EAKmB;AACxB,MAAI,CAACC,iBAAiB,CAACJ,IAAD,CAAtB,EAA8B;AAC5B,WAAO,IAAP;AACD;;AAGD,MAAIK,MAAM,GAAGC,gBAAgB,CAACN,IAAD,EAAOC,OAAP,EAAgB,EAAC,GAAGC,OAAJ;AAAaK,IAAAA,OAAO,EAAE;AAAtB,GAAhB,EAA6CJ,OAA7C,CAA7B;;AACA,MAAIE,MAAJ,EAAY;AACV,WAAOA,MAAP;AACD;;AAID,MAAIR,MAAM,CAACG,IAAD,CAAV,EAAkB;AAChBA,IAAAA,IAAI,GAAG,MAAOA,IAAD,CAAeQ,KAAf,CAAqB,CAArB,EAAwB,EAAxB,EAA4BC,WAA5B,EAAb;AACAJ,IAAAA,MAAM,GAAGC,gBAAgB,CAACN,IAAD,EAAOC,OAAP,EAAgBC,OAAhB,EAAyBC,OAAzB,CAAzB;AACD;;AAGD,MAAI,CAACE,MAAD,IAAW,EAACH,OAAD,aAACA,OAAD,eAACA,OAAO,CAAEK,OAAV,CAAf,EAAkC;AAChC,UAAM,IAAIG,KAAJ,CAAUC,uBAAuB,CAACX,IAAD,CAAjC,CAAN;AACD;;AAED,SAAOK,MAAP;AACD;AAWD,OAAO,SAASC,gBAAT,CACLN,IADK,EAELC,OAA0B,GAAG,EAFxB,EAGLC,OAHK,EAILC,OAJK,EAKU;AACf,MAAI,CAACC,iBAAiB,CAACJ,IAAD,CAAtB,EAA8B;AAC5B,WAAO,IAAP;AACD;;AAKD,MAAIC,OAAO,IAAI,CAACW,KAAK,CAACC,OAAN,CAAcZ,OAAd,CAAhB,EAAwC;AAEtC,WAAOP,eAAe,CAACO,OAAD,CAAtB;AACD;;AAGD,MAAIa,gBAA0B,GAAG,EAAjC;;AAEA,MAAIb,OAAJ,EAAa;AACXa,IAAAA,gBAAgB,GAAGA,gBAAgB,CAACC,MAAjB,CAAwBd,OAAxB,CAAnB;AACD;;AAED,MAAI,EAACC,OAAD,aAACA,OAAD,eAACA,OAAO,CAAEc,uBAAV,CAAJ,EAAuC;AACrCF,IAAAA,gBAAgB,CAACG,IAAjB,CAAsB,GAAGrB,oBAAoB,EAA7C;AACD;;AAGDsB,EAAAA,gBAAgB,CAACJ,gBAAD,CAAhB;AAEA,QAAMT,MAAM,GAAGc,oBAAoB,CAACnB,IAAD,EAAOc,gBAAP,EAAyBZ,OAAzB,EAAkCC,OAAlC,CAAnC;;AAGA,MAAI,CAACE,MAAD,IAAW,EAACH,OAAD,aAACA,OAAD,eAACA,OAAO,CAAEK,OAAV,CAAf,EAAkC;AAChC,UAAM,IAAIG,KAAJ,CAAUC,uBAAuB,CAACX,IAAD,CAAjC,CAAN;AACD;;AAED,SAAOK,MAAP;AACD;;AAGD,SAASc,oBAAT,CACEnB,IADF,EAEEC,OAFF,EAGEC,OAHF,EAIEC,OAJF,EAKE;AACA,QAAM;AAACiB,IAAAA,GAAD;AAAMC,IAAAA;AAAN,MAAc1B,qBAAqB,CAACK,IAAD,CAAzC;AAEA,QAAMsB,OAAO,GAAGF,GAAG,KAAIjB,OAAJ,aAAIA,OAAJ,uBAAIA,OAAO,CAAEiB,GAAb,CAAnB;AAEA,MAAIf,MAAqB,GAAG,IAA5B;;AAGA,MAAIH,OAAJ,aAAIA,OAAJ,eAAIA,OAAO,CAAEqB,QAAb,EAAuB;AACrBlB,IAAAA,MAAM,GAAGmB,oBAAoB,CAACvB,OAAD,EAAUC,OAAV,aAAUA,OAAV,uBAAUA,OAAO,CAAEqB,QAAnB,CAA7B;AACD;;AAEDlB,EAAAA,MAAM,GAAGA,MAAM,IAAIoB,eAAe,CAACxB,OAAD,EAAUqB,OAAV,CAAlC;AAEAjB,EAAAA,MAAM,GAAGA,MAAM,IAAImB,oBAAoB,CAACvB,OAAD,EAAUoB,IAAV,CAAvC;AAEAhB,EAAAA,MAAM,GAAGA,MAAM,IAAIqB,wBAAwB,CAACzB,OAAD,EAAUD,IAAV,CAA3C;AAEAK,EAAAA,MAAM,GAAGA,MAAM,IAAImB,oBAAoB,CAACvB,OAAD,EAAUC,OAAV,aAAUA,OAAV,uBAAUA,OAAO,CAAEyB,gBAAnB,CAAvC;AAEA,SAAOtB,MAAP;AACD;;AAGD,SAASD,iBAAT,CAA2BJ,IAA3B,EAA+C;AAE7C,MAAIA,IAAI,YAAY4B,QAApB,EAA8B;AAE5B,QAAI5B,IAAI,CAAC6B,MAAL,KAAgB,GAApB,EAAyB;AACvB,aAAO,KAAP;AACD;AACF;;AACD,SAAO,IAAP;AACD;;AAED,SAASlB,uBAAT,CAAiCX,IAAjC,EAA+C;AAC7C,QAAM;AAACoB,IAAAA,GAAD;AAAMC,IAAAA;AAAN,MAAc1B,qBAAqB,CAACK,IAAD,CAAzC;AAEA,MAAI8B,OAAO,GAAG,uBAAd;;AACA,MAAI9B,IAAJ,EAAU;AACR8B,IAAAA,OAAO,IAAK,WAAUC,kBAAkB,CAAC/B,IAAD,CAAO,oBAAmBqB,IAAK,GAAvE;AACD;;AACD,MAAID,GAAJ,EAAS;AACPU,IAAAA,OAAO,IAAK,SAAQV,GAAI,EAAxB;AACD;;AACD,SAAOU,OAAP;AACD;;AAED,SAASZ,gBAAT,CAA0BjB,OAA1B,EAAmD;AACjD,OAAK,MAAMI,MAAX,IAAqBJ,OAArB,EAA8B;AAC5BP,IAAAA,eAAe,CAACW,MAAD,CAAf;AACD;AACF;;AAID,SAASoB,eAAT,CAAyBxB,OAAzB,EAA4CmB,GAA5C,EAAyE;AAEvE,QAAMY,KAAK,GAAGZ,GAAG,IAAItB,WAAW,CAACmC,IAAZ,CAAiBb,GAAjB,CAArB;AACA,QAAMc,SAAS,GAAGF,KAAK,IAAIA,KAAK,CAAC,CAAD,CAAhC;AACA,SAAOE,SAAS,GAAGC,qBAAqB,CAAClC,OAAD,EAAUiC,SAAV,CAAxB,GAA+C,IAA/D;AACD;;AAED,SAASC,qBAAT,CAA+BlC,OAA/B,EAAkDiC,SAAlD,EAAoF;AAClFA,EAAAA,SAAS,GAAGA,SAAS,CAACE,WAAV,EAAZ;;AAEA,OAAK,MAAM/B,MAAX,IAAqBJ,OAArB,EAA8B;AAC5B,SAAK,MAAMoC,eAAX,IAA8BhC,MAAM,CAACiC,UAArC,EAAiD;AAC/C,UAAID,eAAe,CAACD,WAAhB,OAAkCF,SAAtC,EAAiD;AAC/C,eAAO7B,MAAP;AACD;AACF;AACF;;AACD,SAAO,IAAP;AACD;;AAED,SAASmB,oBAAT,CAA8BvB,OAA9B,EAAuCsB,QAAvC,EAAiD;AAC/C,OAAK,MAAMlB,MAAX,IAAqBJ,OAArB,EAA8B;AAC5B,QAAII,MAAM,CAACkC,SAAP,IAAoBlC,MAAM,CAACkC,SAAP,CAAiBC,QAAjB,CAA0BjB,QAA1B,CAAxB,EAA6D;AAC3D,aAAOlB,MAAP;AACD;;AAID,QAAIkB,QAAQ,KAAM,iBAAgBlB,MAAM,CAACoC,EAAG,EAA5C,EAA+C;AAC7C,aAAOpC,MAAP;AACD;AACF;;AACD,SAAO,IAAP;AACD;;AAED,SAASqB,wBAAT,CAAkCzB,OAAlC,EAA2CD,IAA3C,EAAiD;AAC/C,MAAI,CAACA,IAAL,EAAW;AACT,WAAO,IAAP;AACD;;AAED,OAAK,MAAMK,MAAX,IAAqBJ,OAArB,EAA8B;AAC5B,QAAI,OAAOD,IAAP,KAAgB,QAApB,EAA8B;AAC5B,UAAI0C,mBAAmB,CAAC1C,IAAD,EAAOK,MAAP,CAAvB,EAAuC;AACrC,eAAOA,MAAP;AACD;AACF,KAJD,MAIO,IAAIsC,WAAW,CAACC,MAAZ,CAAmB5C,IAAnB,CAAJ,EAA8B;AAEnC,UAAI6C,qBAAqB,CAAC7C,IAAI,CAAC8C,MAAN,EAAc9C,IAAI,CAAC+C,UAAnB,EAA+B1C,MAA/B,CAAzB,EAAiE;AAC/D,eAAOA,MAAP;AACD;AACF,KALM,MAKA,IAAIL,IAAI,YAAY2C,WAApB,EAAiC;AACtC,YAAMI,UAAU,GAAG,CAAnB;;AACA,UAAIF,qBAAqB,CAAC7C,IAAD,EAAO+C,UAAP,EAAmB1C,MAAnB,CAAzB,EAAqD;AACnD,eAAOA,MAAP;AACD;AACF;AAEF;;AACD,SAAO,IAAP;AACD;;AAED,SAASqC,mBAAT,CAA6B1C,IAA7B,EAAmCK,MAAnC,EAA2C;AACzC,MAAIA,MAAM,CAAC2C,QAAX,EAAqB;AACnB,WAAO3C,MAAM,CAAC2C,QAAP,CAAgBhD,IAAhB,CAAP;AACD;;AAED,QAAMiD,KAAK,GAAGrC,KAAK,CAACC,OAAN,CAAcR,MAAM,CAAC4C,KAArB,IAA8B5C,MAAM,CAAC4C,KAArC,GAA6C,CAAC5C,MAAM,CAAC4C,KAAR,CAA3D;AACA,SAAOA,KAAK,CAACC,IAAN,CAAYC,IAAD,IAAUnD,IAAI,CAACoD,UAAL,CAAgBD,IAAhB,CAArB,CAAP;AACD;;AAED,SAASN,qBAAT,CAA+B7C,IAA/B,EAAqC+C,UAArC,EAAiD1C,MAAjD,EAAyD;AACvD,QAAM4C,KAAK,GAAGrC,KAAK,CAACC,OAAN,CAAcR,MAAM,CAAC4C,KAArB,IAA8B5C,MAAM,CAAC4C,KAArC,GAA6C,CAAC5C,MAAM,CAAC4C,KAAR,CAA3D;AACA,SAAOA,KAAK,CAACC,IAAN,CAAYC,IAAD,IAAUE,UAAU,CAACrD,IAAD,EAAO+C,UAAP,EAAmB1C,MAAnB,EAA2B8C,IAA3B,CAA/B,CAAP;AACD;;AAED,SAASE,UAAT,CAAoBrD,IAApB,EAA0B+C,UAA1B,EAAsC1C,MAAtC,EAA8C8C,IAA9C,EAAoD;AAClD,MAAIA,IAAI,YAAYR,WAApB,EAAiC;AAC/B,WAAOlD,mBAAmB,CAAC0D,IAAD,EAAOnD,IAAP,EAAamD,IAAI,CAACG,UAAlB,CAA1B;AACD;;AACD,UAAQ,OAAOH,IAAf;AACE,SAAK,UAAL;AACE,aAAOA,IAAI,CAACnD,IAAD,EAAOK,MAAP,CAAX;;AAEF,SAAK,QAAL;AAEE,YAAMkD,KAAK,GAAGC,cAAc,CAACxD,IAAD,EAAO+C,UAAP,EAAmBI,IAAI,CAACM,MAAxB,CAA5B;AACA,aAAON,IAAI,KAAKI,KAAhB;;AAEF;AACE,aAAO,KAAP;AAVJ;AAYD;;AAED,SAASxB,kBAAT,CAA4B/B,IAA5B,EAAkCyD,MAAM,GAAG,CAA3C,EAA8C;AAC5C,MAAI,OAAOzD,IAAP,KAAgB,QAApB,EAA8B;AAC5B,WAAOA,IAAI,CAACQ,KAAL,CAAW,CAAX,EAAciD,MAAd,CAAP;AACD,GAFD,MAEO,IAAId,WAAW,CAACC,MAAZ,CAAmB5C,IAAnB,CAAJ,EAA8B;AAEnC,WAAOwD,cAAc,CAACxD,IAAI,CAAC8C,MAAN,EAAc9C,IAAI,CAAC+C,UAAnB,EAA+BU,MAA/B,CAArB;AACD,GAHM,MAGA,IAAIzD,IAAI,YAAY2C,WAApB,EAAiC;AACtC,UAAMI,UAAU,GAAG,CAAnB;AACA,WAAOS,cAAc,CAACxD,IAAD,EAAO+C,UAAP,EAAmBU,MAAnB,CAArB;AACD;;AACD,SAAO,EAAP;AACD;;AAED,SAASD,cAAT,CAAwB/C,WAAxB,EAAqCsC,UAArC,EAAiDU,MAAjD,EAAyD;AACvD,MAAIhD,WAAW,CAAC6C,UAAZ,GAAyBP,UAAU,GAAGU,MAA1C,EAAkD;AAChD,WAAO,EAAP;AACD;;AACD,QAAMC,QAAQ,GAAG,IAAIC,QAAJ,CAAalD,WAAb,CAAjB;AACA,MAAI8C,KAAK,GAAG,EAAZ;;AACA,OAAK,IAAIK,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,MAApB,EAA4BG,CAAC,EAA7B,EAAiC;AAC/BL,IAAAA,KAAK,IAAIM,MAAM,CAACC,YAAP,CAAoBJ,QAAQ,CAACK,QAAT,CAAkBhB,UAAU,GAAGa,CAA/B,CAApB,CAAT;AACD;;AACD,SAAOL,KAAP;AACD","sourcesContent":["import type {LoaderContext, LoaderOptions, Loader} from '@loaders.gl/loader-utils';\r\nimport {compareArrayBuffers} from '@loaders.gl/loader-utils';\r\nimport {normalizeLoader} from '../loader-utils/normalize-loader';\r\nimport {getResourceUrlAndType} from '../utils/resource-utils';\r\nimport {getRegisteredLoaders} from './register-loaders';\r\nimport {isBlob} from '../../javascript-utils/is-type';\r\n\r\nconst EXT_PATTERN = /\\.([^.]+)$/;\r\n\r\n// TODO - Need a variant that peeks at streams for parseInBatches\r\n// TODO - Detect multiple matching loaders? Use heuristics to grade matches?\r\n// TODO - Allow apps to pass context to disambiguate between multiple matches (e.g. multiple .json formats)?\r\n\r\n/**\r\n * Find a loader that matches file extension and/or initial file content\r\n * Search the loaders array argument for a loader that matches url extension or initial data\r\n * Returns: a normalized loader\r\n * @param data data to assist\r\n * @param loaders\r\n * @param options\r\n * @param context used internally, applications should not provide this parameter\r\n */\r\nexport async function selectLoader(\r\n  data: Response | Blob | ArrayBuffer | string,\r\n  loaders: Loader[] | Loader = [],\r\n  options?: LoaderOptions,\r\n  context?: LoaderContext\r\n): Promise<Loader | null> {\r\n  if (!validHTTPResponse(data)) {\r\n    return null;\r\n  }\r\n\r\n  // First make a sync attempt, disabling exceptions\r\n  let loader = selectLoaderSync(data, loaders, {...options, nothrow: true}, context);\r\n  if (loader) {\r\n    return loader;\r\n  }\r\n\r\n  // For Blobs and Files, try to asynchronously read a small initial slice and test again with that\r\n  // to see if we can detect by initial content\r\n  if (isBlob(data)) {\r\n    data = await (data as Blob).slice(0, 10).arrayBuffer();\r\n    loader = selectLoaderSync(data, loaders, options, context);\r\n  }\r\n\r\n  // no loader available\r\n  if (!loader && !options?.nothrow) {\r\n    throw new Error(getNoValidLoaderMessage(data));\r\n  }\r\n\r\n  return loader;\r\n}\r\n\r\n/**\r\n * Find a loader that matches file extension and/or initial file content\r\n * Search the loaders array argument for a loader that matches url extension or initial data\r\n * Returns: a normalized loader\r\n * @param data data to assist\r\n * @param loaders\r\n * @param options\r\n * @param context used internally, applications should not provide this parameter\r\n */\r\nexport function selectLoaderSync(\r\n  data: Response | Blob | ArrayBuffer | string,\r\n  loaders: Loader[] | Loader = [],\r\n  options?: LoaderOptions,\r\n  context?: LoaderContext\r\n): Loader | null {\r\n  if (!validHTTPResponse(data)) {\r\n    return null;\r\n  }\r\n\r\n  // eslint-disable-next-line complexity\r\n  // if only a single loader was provided (not as array), force its use\r\n  // TODO - Should this behavior be kept and documented?\r\n  if (loaders && !Array.isArray(loaders)) {\r\n    // TODO - remove support for legacy loaders\r\n    return normalizeLoader(loaders);\r\n  }\r\n\r\n  // Build list of candidate loaders that will be searched in order for a match\r\n  let candidateLoaders: Loader[] = [];\r\n  // First search supplied loaders\r\n  if (loaders) {\r\n    candidateLoaders = candidateLoaders.concat(loaders);\r\n  }\r\n  // Then fall back to registered loaders\r\n  if (!options?.ignoreRegisteredLoaders) {\r\n    candidateLoaders.push(...getRegisteredLoaders());\r\n  }\r\n\r\n  // TODO - remove support for legacy loaders\r\n  normalizeLoaders(candidateLoaders);\r\n\r\n  const loader = selectLoaderInternal(data, candidateLoaders, options, context);\r\n\r\n  // no loader available\r\n  if (!loader && !options?.nothrow) {\r\n    throw new Error(getNoValidLoaderMessage(data));\r\n  }\r\n\r\n  return loader;\r\n}\r\n\r\n/** Implements loaders selection logic */\r\nfunction selectLoaderInternal(\r\n  data: Response | Blob | ArrayBuffer | string,\r\n  loaders: Loader[],\r\n  options?: LoaderOptions,\r\n  context?: LoaderContext\r\n) {\r\n  const {url, type} = getResourceUrlAndType(data);\r\n\r\n  const testUrl = url || context?.url;\r\n\r\n  let loader: Loader | null = null;\r\n\r\n  // if options.mimeType is supplied, it takes precedence\r\n  if (options?.mimeType) {\r\n    loader = findLoaderByMIMEType(loaders, options?.mimeType);\r\n  }\r\n  // Look up loader by url\r\n  loader = loader || findLoaderByUrl(loaders, testUrl);\r\n  // Look up loader by mime type\r\n  loader = loader || findLoaderByMIMEType(loaders, type);\r\n  // Look for loader via initial bytes (Note: not always accessible (e.g. Response, stream, async iterator)\r\n  loader = loader || findLoaderByInitialBytes(loaders, data);\r\n  // Look up loader by fallback mime type\r\n  loader = loader || findLoaderByMIMEType(loaders, options?.fallbackMimeType);\r\n\r\n  return loader;\r\n}\r\n\r\n/** Check HTTP Response */\r\nfunction validHTTPResponse(data: any): boolean {\r\n  // HANDLE HTTP status\r\n  if (data instanceof Response) {\r\n    // 204 - NO CONTENT. This handles cases where e.g. a tile server responds with 204 for a missing tile\r\n    if (data.status === 204) {\r\n      return false;\r\n    }\r\n  }\r\n  return true;\r\n}\r\n\r\nfunction getNoValidLoaderMessage(data): string {\r\n  const {url, type} = getResourceUrlAndType(data);\r\n\r\n  let message = 'No valid loader found';\r\n  if (data) {\r\n    message += ` data: \"${getFirstCharacters(data)}\", contentType: \"${type}\"`;\r\n  }\r\n  if (url) {\r\n    message += ` url: ${url}`;\r\n  }\r\n  return message;\r\n}\r\n\r\nfunction normalizeLoaders(loaders: Loader[]): void {\r\n  for (const loader of loaders) {\r\n    normalizeLoader(loader);\r\n  }\r\n}\r\n\r\n// TODO - Would be nice to support http://example.com/file.glb?parameter=1\r\n// E.g: x = new URL('http://example.com/file.glb?load=1'; x.pathname\r\nfunction findLoaderByUrl(loaders: Loader[], url?: string): Loader | null {\r\n  // Get extension\r\n  const match = url && EXT_PATTERN.exec(url);\r\n  const extension = match && match[1];\r\n  return extension ? findLoaderByExtension(loaders, extension) : null;\r\n}\r\n\r\nfunction findLoaderByExtension(loaders: Loader[], extension: string): Loader | null {\r\n  extension = extension.toLowerCase();\r\n\r\n  for (const loader of loaders) {\r\n    for (const loaderExtension of loader.extensions) {\r\n      if (loaderExtension.toLowerCase() === extension) {\r\n        return loader;\r\n      }\r\n    }\r\n  }\r\n  return null;\r\n}\r\n\r\nfunction findLoaderByMIMEType(loaders, mimeType) {\r\n  for (const loader of loaders) {\r\n    if (loader.mimeTypes && loader.mimeTypes.includes(mimeType)) {\r\n      return loader;\r\n    }\r\n\r\n    // Support referring to loaders using the \"unregistered tree\"\r\n    // https://en.wikipedia.org/wiki/Media_type#Unregistered_tree\r\n    if (mimeType === `application/x.${loader.id}`) {\r\n      return loader;\r\n    }\r\n  }\r\n  return null;\r\n}\r\n\r\nfunction findLoaderByInitialBytes(loaders, data) {\r\n  if (!data) {\r\n    return null;\r\n  }\r\n\r\n  for (const loader of loaders) {\r\n    if (typeof data === 'string') {\r\n      if (testDataAgainstText(data, loader)) {\r\n        return loader;\r\n      }\r\n    } else if (ArrayBuffer.isView(data)) {\r\n      // Typed Arrays can have offsets into underlying buffer\r\n      if (testDataAgainstBinary(data.buffer, data.byteOffset, loader)) {\r\n        return loader;\r\n      }\r\n    } else if (data instanceof ArrayBuffer) {\r\n      const byteOffset = 0;\r\n      if (testDataAgainstBinary(data, byteOffset, loader)) {\r\n        return loader;\r\n      }\r\n    }\r\n    // TODO Handle streaming case (requires creating a new AsyncIterator)\r\n  }\r\n  return null;\r\n}\r\n\r\nfunction testDataAgainstText(data, loader) {\r\n  if (loader.testText) {\r\n    return loader.testText(data);\r\n  }\r\n\r\n  const tests = Array.isArray(loader.tests) ? loader.tests : [loader.tests];\r\n  return tests.some((test) => data.startsWith(test));\r\n}\r\n\r\nfunction testDataAgainstBinary(data, byteOffset, loader) {\r\n  const tests = Array.isArray(loader.tests) ? loader.tests : [loader.tests];\r\n  return tests.some((test) => testBinary(data, byteOffset, loader, test));\r\n}\r\n\r\nfunction testBinary(data, byteOffset, loader, test) {\r\n  if (test instanceof ArrayBuffer) {\r\n    return compareArrayBuffers(test, data, test.byteLength);\r\n  }\r\n  switch (typeof test) {\r\n    case 'function':\r\n      return test(data, loader);\r\n\r\n    case 'string':\r\n      // Magic bytes check: If `test` is a string, check if binary data starts with that strings\r\n      const magic = getMagicString(data, byteOffset, test.length);\r\n      return test === magic;\r\n\r\n    default:\r\n      return false;\r\n  }\r\n}\r\n\r\nfunction getFirstCharacters(data, length = 5) {\r\n  if (typeof data === 'string') {\r\n    return data.slice(0, length);\r\n  } else if (ArrayBuffer.isView(data)) {\r\n    // Typed Arrays can have offsets into underlying buffer\r\n    return getMagicString(data.buffer, data.byteOffset, length);\r\n  } else if (data instanceof ArrayBuffer) {\r\n    const byteOffset = 0;\r\n    return getMagicString(data, byteOffset, length);\r\n  }\r\n  return '';\r\n}\r\n\r\nfunction getMagicString(arrayBuffer, byteOffset, length) {\r\n  if (arrayBuffer.byteLength < byteOffset + length) {\r\n    return '';\r\n  }\r\n  const dataView = new DataView(arrayBuffer);\r\n  let magic = '';\r\n  for (let i = 0; i < length; i++) {\r\n    magic += String.fromCharCode(dataView.getUint8(byteOffset + i));\r\n  }\r\n  return magic;\r\n}\r\n"],"file":"select-loader.js"}