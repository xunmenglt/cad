{"version":3,"sources":["../../../src/lib/api/encode.ts"],"names":["concatenateArrayBuffers","resolvePath","isBrowser","writeFile","fetchFile","encode","data","writer","options","encodeSync","encodeText","TextEncoder","encodeInBatches","batches","chunks","batch","push","encodeURLtoURL","tmpInputFilename","getTemporaryFilename","tmpOutputFilename","outputFilename","response","arrayBuffer","Error","text","TextDecoder","decode","dataIterator","getIterator","inputUrl","outputUrl","table","start","end","length","filename"],"mappings":"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","sourcesContent":["import type {Writer, LoaderOptions} from '@loaders.gl/loader-utils';\r\nimport {concatenateArrayBuffers, resolvePath} from '@loaders.gl/loader-utils';\r\nimport {isBrowser} from '@loaders.gl/loader-utils';\r\nimport {writeFile} from '../fetch/write-file';\r\nimport {fetchFile} from '../fetch/fetch-file';\r\n\r\n/**\r\n * Encode loaded data into a binary ArrayBuffer using the specified Writer.\r\n */\r\nexport async function encode(\r\n  data: any,\r\n  writer: Writer,\r\n  options?: LoaderOptions\r\n): Promise<ArrayBuffer> {\r\n  if (writer.encode) {\r\n    return await writer.encode(data, options);\r\n  }\r\n\r\n  if (writer.encodeSync) {\r\n    return writer.encodeSync(data, options);\r\n  }\r\n\r\n  if (writer.encodeText) {\r\n    return new TextEncoder().encode(await writer.encodeText(data, options));\r\n  }\r\n\r\n  if (writer.encodeInBatches) {\r\n    // Create an iterator representing the data\r\n    // TODO - Assumes this is a table\r\n    const batches = encodeInBatches(data, writer, options);\r\n\r\n    // Concatenate the output\r\n    const chunks: any[] = [];\r\n    for await (const batch of batches) {\r\n      chunks.push(batch);\r\n    }\r\n    // @ts-ignore\r\n    return concatenateArrayBuffers(...chunks);\r\n  }\r\n\r\n  if (!isBrowser && writer.encodeURLtoURL) {\r\n    // TODO - how to generate filenames with correct extensions?\r\n    const tmpInputFilename = getTemporaryFilename('input');\r\n    await writeFile(tmpInputFilename, data);\r\n\r\n    const tmpOutputFilename = getTemporaryFilename('output');\r\n\r\n    const outputFilename = await encodeURLtoURL(\r\n      tmpInputFilename,\r\n      tmpOutputFilename,\r\n      writer,\r\n      options\r\n    );\r\n\r\n    const response = await fetchFile(outputFilename);\r\n    return response.arrayBuffer();\r\n  }\r\n\r\n  throw new Error('Writer could not encode data');\r\n}\r\n\r\n/**\r\n * Encode loaded data into a binary ArrayBuffer using the specified Writer.\r\n */\r\nexport function encodeSync(data: any, writer: Writer, options?: LoaderOptions): ArrayBuffer {\r\n  if (writer.encodeSync) {\r\n    return writer.encodeSync(data, options);\r\n  }\r\n  throw new Error('Writer could not synchronously encode data');\r\n}\r\n\r\n/**\r\n * Encode loaded data to text using the specified Writer\r\n * @note This is a convenience function not intended for production use on large input data.\r\n * It is not optimized for performance. Data maybe converted from text to binary and back.\r\n * @throws if the writer does not generate text output\r\n */\r\nexport async function encodeText(\r\n  data: any,\r\n  writer: Writer,\r\n  options?: LoaderOptions\r\n): Promise<string> {\r\n  if (writer.text && writer.encodeText) {\r\n    return await writer.encodeText(data, options);\r\n  }\r\n\r\n  if (writer.text && (writer.encode || writer.encodeInBatches)) {\r\n    const arrayBuffer = await encode(data, writer, options);\r\n    return new TextDecoder().decode(arrayBuffer);\r\n  }\r\n\r\n  throw new Error('Writer could not encode data as text');\r\n}\r\n\r\n/**\r\n * Encode loaded data into a sequence (iterator) of binary ArrayBuffers using the specified Writer.\r\n */\r\nexport function encodeInBatches(\r\n  data: any,\r\n  writer: Writer,\r\n  options?: LoaderOptions\r\n): AsyncIterable<ArrayBuffer> {\r\n  if (writer.encodeInBatches) {\r\n    const dataIterator = getIterator(data);\r\n    return writer.encodeInBatches(dataIterator, options);\r\n  }\r\n  // TODO -fall back to atomic encode?\r\n  throw new Error('Writer could not encode data in batches');\r\n}\r\n\r\n/**\r\n * Encode data stored in a file (on disk) to another file.\r\n * @note Node.js only. This function enables using command-line converters as \"writers\".\r\n */\r\nexport async function encodeURLtoURL(\r\n  inputUrl,\r\n  outputUrl,\r\n  writer: Writer,\r\n  options\r\n): Promise<string> {\r\n  inputUrl = resolvePath(inputUrl);\r\n  outputUrl = resolvePath(outputUrl);\r\n  if (isBrowser || !writer.encodeURLtoURL) {\r\n    throw new Error();\r\n  }\r\n  const outputFilename = await writer.encodeURLtoURL(inputUrl, outputUrl, options);\r\n  return outputFilename;\r\n}\r\n\r\n/**\r\n * @todo TODO - this is an unacceptable hack!!!\r\n */\r\nfunction getIterator(data) {\r\n  const dataIterator = [{table: data, start: 0, end: data.length}];\r\n  return dataIterator;\r\n}\r\n\r\n/**\r\n * @todo Move to utils\r\n */\r\nfunction getTemporaryFilename(filename: string): string {\r\n  return `/tmp/${filename}`;\r\n}\r\n"],"file":"encode.js"}