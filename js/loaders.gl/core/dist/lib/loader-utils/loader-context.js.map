{"version":3,"sources":["../../../src/lib/loader-utils/loader-context.ts"],"names":["getFetchFunction","getLoaderContext","context","options","previousContext","resolvedContext","fetch","Array","isArray","loaders","getLoadersFromContext","candidateLoaders","contextLoaders","length"],"mappings":"AACA,SAAQA,gBAAR,QAA+B,gBAA/B;AAWA,OAAO,SAASC,gBAAT,CACLC,OADK,EAELC,OAFK,EAGLC,eAAqC,GAAG,IAHnC,EAIU;AAGf,MAAIA,eAAJ,EAAqB;AACnB,WAAOA,eAAP;AACD;;AAED,QAAMC,eAA8B,GAAG;AACrCC,IAAAA,KAAK,EAAEN,gBAAgB,CAACG,OAAD,EAAUD,OAAV,CADc;AAErC,OAAGA;AAFkC,GAAvC;;AAMA,MAAI,CAACK,KAAK,CAACC,OAAN,CAAcH,eAAe,CAACI,OAA9B,CAAL,EAA6C;AAC3CJ,IAAAA,eAAe,CAACI,OAAhB,GAA0B,IAA1B;AACD;;AAED,SAAOJ,eAAP;AACD;AAGD,OAAO,SAASK,qBAAT,CACLD,OADK,EAELP,OAFK,EAGL;AAEA,MAAI,CAACA,OAAD,IAAYO,OAAZ,IAAuB,CAACF,KAAK,CAACC,OAAN,CAAcC,OAAd,CAA5B,EAAoD;AAClD,WAAOA,OAAP;AACD;;AAGD,MAAIE,gBAAJ;;AACA,MAAIF,OAAJ,EAAa;AACXE,IAAAA,gBAAgB,GAAGJ,KAAK,CAACC,OAAN,CAAcC,OAAd,IAAyBA,OAAzB,GAAmC,CAACA,OAAD,CAAtD;AACD;;AACD,MAAIP,OAAO,IAAIA,OAAO,CAACO,OAAvB,EAAgC;AAC9B,UAAMG,cAAc,GAAGL,KAAK,CAACC,OAAN,CAAcN,OAAO,CAACO,OAAtB,IAAiCP,OAAO,CAACO,OAAzC,GAAmD,CAACP,OAAO,CAACO,OAAT,CAA1E;AACAE,IAAAA,gBAAgB,GAAGA,gBAAgB,GAAG,CAAC,GAAGA,gBAAJ,EAAsB,GAAGC,cAAzB,CAAH,GAA8CA,cAAjF;AACD;;AAED,SAAOD,gBAAgB,IAAIA,gBAAgB,CAACE,MAArC,GAA8CF,gBAA9C,GAAiE,IAAxE;AACD","sourcesContent":["import type {Loader, LoaderOptions, LoaderContext} from '@loaders.gl/loader-utils';\r\nimport {getFetchFunction} from './option-utils';\r\n\r\n/**\r\n * \"sub\" loaders invoked by other loaders get a \"context\" injected on `this`\r\n * The context will inject core methods like `parse` and contain information\r\n * about loaders and options passed in to the top-level `parse` call.\r\n *\r\n * @param context\r\n * @param options\r\n * @param previousContext\r\n */\r\nexport function getLoaderContext(\r\n  context: Omit<LoaderContext, 'fetch'> & Partial<Pick<LoaderContext, 'fetch'>>,\r\n  options?: LoaderOptions,\r\n  previousContext: LoaderContext | null = null\r\n): LoaderContext {\r\n  // For recursive calls, we already have a context\r\n  // TODO - add any additional loaders to context?\r\n  if (previousContext) {\r\n    return previousContext;\r\n  }\r\n\r\n  const resolvedContext: LoaderContext = {\r\n    fetch: getFetchFunction(options, context),\r\n    ...context\r\n  };\r\n\r\n  // Recursive loading does not use single loader\r\n  if (!Array.isArray(resolvedContext.loaders)) {\r\n    resolvedContext.loaders = null;\r\n  }\r\n\r\n  return resolvedContext;\r\n}\r\n\r\n// eslint-disable-next-line complexity\r\nexport function getLoadersFromContext(\r\n  loaders: Loader[] | Loader | undefined,\r\n  context?: LoaderContext\r\n) {\r\n  // A single non-array loader is force selected, but only on top-level (context === null)\r\n  if (!context && loaders && !Array.isArray(loaders)) {\r\n    return loaders;\r\n  }\r\n\r\n  // Create a merged list\r\n  let candidateLoaders;\r\n  if (loaders) {\r\n    candidateLoaders = Array.isArray(loaders) ? loaders : [loaders];\r\n  }\r\n  if (context && context.loaders) {\r\n    const contextLoaders = Array.isArray(context.loaders) ? context.loaders : [context.loaders];\r\n    candidateLoaders = candidateLoaders ? [...candidateLoaders, ...contextLoaders] : contextLoaders;\r\n  }\r\n  // If no loaders, return null to look in globally registered loaders\r\n  return candidateLoaders && candidateLoaders.length ? candidateLoaders : null;\r\n}\r\n"],"file":"loader-context.js"}