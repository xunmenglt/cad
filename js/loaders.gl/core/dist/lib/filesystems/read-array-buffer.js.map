{"version":3,"sources":["../../../src/lib/filesystems/read-array-buffer.ts"],"names":["readArrayBuffer","file","start","length","Blob","slice","arrayBuffer","read"],"mappings":"AAEA,OAAO,eAAeA,eAAf,CACLC,IADK,EAELC,KAFK,EAGLC,MAHK,EAIiB;AACtB,MAAIF,IAAI,YAAYG,IAApB,EAA0B;AACxB,UAAMC,KAAK,GAAGJ,IAAI,CAACI,KAAL,CAAWH,KAAX,EAAkBA,KAAK,GAAGC,MAA1B,CAAd;AACA,WAAO,MAAME,KAAK,CAACC,WAAN,EAAb;AACD;;AACD,SAAO,MAAML,IAAI,CAACM,IAAL,CAAUL,KAAV,EAAiBA,KAAK,GAAGC,MAAzB,CAAb;AACD","sourcesContent":["// Random-Access read\r\n\r\nexport async function readArrayBuffer(\r\n  file: Blob | ArrayBuffer | any,\r\n  start: number,\r\n  length: number\r\n): Promise<ArrayBuffer> {\r\n  if (file instanceof Blob) {\r\n    const slice = file.slice(start, start + length);\r\n    return await slice.arrayBuffer();\r\n  }\r\n  return await file.read(start, start + length);\r\n}\r\n\r\n/**\r\n * Read a slice of a Blob or File, without loading the entire file into memory\r\n * The trick when reading File objects is to read successive \"slices\" of the File\r\n * Per spec https://w3c.github.io/FileAPI/, slicing a File only updates the start and end fields\r\n * Actually reading from file happens in `readAsArrayBuffer`\r\n * @param blob to read\r\n export async function readBlob(blob: Blob): Promise<ArrayBuffer> {\r\n  return await new Promise((resolve, reject) => {\r\n    const fileReader = new FileReader();\r\n    fileReader.onload = (event: ProgressEvent<FileReader>) =>\r\n      resolve(event?.target?.result as ArrayBuffer);\r\n    // TODO - reject with a proper Error\r\n    fileReader.onerror = (error: ProgressEvent<FileReader>) => reject(error);\r\n    fileReader.readAsArrayBuffer(blob);\r\n  });\r\n}\r\n*/\r\n"],"file":"read-array-buffer.js"}